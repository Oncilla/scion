# Copyright 2014 ETH Zurich
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
:mod:`trc` --- SCION TRC parser
===============================================
"""
# Stdlib
import base64
import copy
import json
import os
import time

# External
import lz4

# SCION
from lib.crypto.asymcrypto import verify, sign
from lib.crypto.util import CERT_DIR
from lib.errors import SCIONVerificationError
from lib.packet.scion_addr import ISD_AS

ISD_STRING = 'ISD'
DESCRIPTION_STRING = 'Description'
VERSION_STRING = 'Version'
CREATION_TIME_STRING = 'CreationTime'
EXPIRATION_TIME_STRING = 'ExpirationTime'
CORE_ASES_STRING = 'CoreCAs'
ROOT_CAS_STRING = 'RootCAs'
PKI_LOGS_STRING = 'PKILogs'
QUORUM_EEPKI_STRING = 'QuorumEEPKI'
ROOT_RAINS_KEY_STRING = 'RootRainsKey'
QUORUM_TRC_STRING = 'QuorumTRC'
QUORUM_CAS_STRING = 'QuorumCAs'
QUARANTINE_STRING = 'Quarantine'
SIGNATURES_STRING = 'Signatures'
GRACE_PERIOD_STRING = 'GracePeriod'
ONLINE_KEY_ALG_STRING = 'OnlineKeyAlg'
ONLINE_KEY_STRING = 'OnlineKey'
OFFLINE_KEY_ALG_STRING = 'OfflineKeyAlg'
OFFLINE_KEY_STRING = 'OfflineKey'


def get_trc_file_path(conf_dir, isd, version):  # pragma: no cover
    """
    Return the TRC file path for a given ISD.
    """
    return os.path.join(conf_dir, CERT_DIR, 'ISD%s-V%s.trc' % (isd, version))


class TRC(object):
    """
    The TRC class parses the TRC file of an ISD and stores such
    information for further use.

    :ivar int isd: the ISD identifier.
    :ivar str description: is a human readable description of an ISD.
    :ivar int version: the TRC file version.
    :ivar int create_time: the TRC file creation timestamp.
    :ivar int exp_time: the TRC expiration timestamp.
    :ivar dict core_ases: the set of core ASes and their certificates.
    :ivar dict root_cas: the set of root CAs and their certificates.
    :ivar dict pki_logs: is a dictionary of end entity certificate logs, and
        their addresses and public key certificates
    :ivar int quroum_eepki: is a threshold number (nonnegative integer) of
        CAs that have to sign a domainâ€™s policy
    :ivar str root_rains_key: the RAINS root public key.
    :ivar int quorum_trc: number of core ASes necessary to sign a new TRC.
    :ivar int quorum_cas: number of CAs necessary to change CA entries
    :ivar int grace_period: defines for how long this TRC is valid when a new
        TRC is available
    :ivar bool quarantine: flag defining whether TRC is valid(quarantine=false)
        or an early annoncement(quarantine=true)
    :ivar dict signatures: signatures generated by a quorum of trust roots.
    """

    VALIDITY_PERIOD = 365 * 24 * 60 * 60

    FIELDS_MAP = {
        ISD_STRING: ("isd", int),
        DESCRIPTION_STRING: ("description", str),
        VERSION_STRING: ("version", int),
        CREATION_TIME_STRING: ("create_time", int),
        EXPIRATION_TIME_STRING: ("exp_time", int),
        CORE_ASES_STRING: ("core_ases", dict),
        ROOT_CAS_STRING: ("root_cas", dict),
        PKI_LOGS_STRING: ("pki_logs", dict),
        QUORUM_EEPKI_STRING: ("quorum_eepki", int),
        ROOT_RAINS_KEY_STRING: ("root_rains_key", bytes),
        QUORUM_TRC_STRING: ("quorum_trc", int),
        QUORUM_CAS_STRING: ("quorum_cas", int),
        QUARANTINE_STRING: ("quarantine", bool),
        SIGNATURES_STRING: ("signatures", dict),
        GRACE_PERIOD_STRING: ("grace_period", int),
    }

    def __init__(self, trc_dict):
        """
        :param dict trc_dict: TRC as dict.
        """
        for k, (name, type_) in self.FIELDS_MAP.items():
            val = trc_dict[k]
            if type_ in (int,):
                val = int(val)
            elif type_ in (dict, ):
                val = copy.deepcopy(val)
            setattr(self, name, val)
        for subject in trc_dict[CORE_ASES_STRING]:
            key = trc_dict[CORE_ASES_STRING][subject][ONLINE_KEY_STRING]
            self.core_ases[subject][ONLINE_KEY_STRING] = \
                base64.b64decode(key.encode('utf-8'))
            key = trc_dict[CORE_ASES_STRING][subject][OFFLINE_KEY_STRING]
            self.core_ases[subject][OFFLINE_KEY_STRING] = \
                base64.b64decode(key.encode('utf-8'))
        for subject in trc_dict[SIGNATURES_STRING]:
            sig = trc_dict[SIGNATURES_STRING][subject]
            self.signatures[subject] = \
                base64.b64decode(sig.encode('utf-8'))
        for subject in trc_dict[ROOT_CAS_STRING]:
            self.root_cas[subject] = base64.b64decode(
                trc_dict[ROOT_CAS_STRING][subject].encode('utf-8'))

    def get_isd_ver(self):
        return self.isd, self.version

    def get_core_ases(self):
        res = []
        for key in self.core_ases:
            res.append(ISD_AS(key))
        return res

    def dict(self, with_signatures):
        """
        Return the TRC information.

        :param bool with_signatures:
            If True, include signatures in the return value.
        :returns: the TRC information.
        :rtype: dict
        """
        trc_dict = {}
        for k, (name, _) in self.FIELDS_MAP.items():
            trc_dict[k] = getattr(self, name)
        if not with_signatures:
            del trc_dict[SIGNATURES_STRING]
        return trc_dict

    @classmethod
    def from_raw(cls, trc_raw, lz4_=False):
        if lz4_:
            trc_raw = lz4.loads(trc_raw).decode("utf-8")
        trc = json.loads(trc_raw)
        return TRC(trc)

    @classmethod
    def from_values(cls, isd, description, version, core_ases, root_cas, pki_logs,
                    quorum_eepki, root_rains_key, quorum_trc, quorum_cas, grace_period,
                    validity_period, quarantine, signatures):
        """
        Generate a TRC instance.
        """
        now = int(time.time())
        trc_dict = {
            ISD_STRING: isd,
            DESCRIPTION_STRING: description,
            VERSION_STRING: version,
            CREATION_TIME_STRING: now,
            EXPIRATION_TIME_STRING: now + validity_period,
            CORE_ASES_STRING: core_ases,
            ROOT_CAS_STRING: root_cas,
            PKI_LOGS_STRING: pki_logs,
            QUORUM_EEPKI_STRING: quorum_eepki,
            ROOT_RAINS_KEY_STRING: root_rains_key,
            QUORUM_TRC_STRING: quorum_trc,
            QUORUM_CAS_STRING: quorum_cas,
            GRACE_PERIOD_STRING: grace_period,
            QUARANTINE_STRING: quarantine,
            SIGNATURES_STRING: signatures,
        }
        trc = TRC(trc_dict)
        return trc

    def sign(self, isd_as, sig_priv_key):
        data = self._sig_input()
        self.signatures[isd_as] = sign(data, sig_priv_key)

    def _sig_input(self):
        d = self.dict(False)
        for k in d:
            if self.FIELDS_MAP[k][1] == str:
                d[k] = base64.b64encode(d[k].encode('utf-8')).decode('utf-8')
            elif self.FIELDS_MAP[k][1] == dict:
                d[k] = self._encode_dict(d[k])
        j = json.dumps(d, sort_keys=True, separators=(',', ':'))
        return j.encode('utf-8')

    def _encode_dict(self, dict_):
        encoded_dict = {}
        for key_ in dict_:
            if type(dict_[key_]) is str:
                encoded_dict[key_] = base64.b64encode(
                    dict_[key_].encode('utf-8')).decode('utf-8')
        return encoded_dict

    def to_json(self, with_signatures=True):
        """
        Convert the instance to json format.
        """
        trc_dict = copy.deepcopy(self.dict(with_signatures))
        core_ases = {}
        for subject in trc_dict[CORE_ASES_STRING]:
            d = trc_dict[CORE_ASES_STRING][subject]
            for key in (ONLINE_KEY_STRING, OFFLINE_KEY_STRING, ):
                key_ = trc_dict[CORE_ASES_STRING][subject][key]
                d[key] = base64.b64encode(key_).decode('utf-8')
            core_ases[subject] = d
        trc_dict[CORE_ASES_STRING] = core_ases
        root_cas = {}
        for subject, cert_str in trc_dict[ROOT_CAS_STRING].items():
            root_cas[subject] = base64.b64encode(cert_str).decode('utf-8')
        trc_dict[ROOT_CAS_STRING] = root_cas
        if with_signatures:
            signatures = {}
            for subject in trc_dict[SIGNATURES_STRING]:
                signature = trc_dict[SIGNATURES_STRING][subject]
                signatures[subject] = base64.b64encode(
                    signature).decode('utf-8')
            trc_dict[SIGNATURES_STRING] = signatures
        trc_str = json.dumps(trc_dict, sort_keys=True, indent=4)
        return trc_str

    def pack(self, lz4_=False):
        ret = self.to_json().encode('utf-8')
        if lz4_:
            return lz4.dumps(ret)
        return ret

    def __str__(self):
        return self.to_json()

    def __eq__(self, other):  # pragma: no cover
        return str(self) == str(other)

    def check_active(self, max_trc=None):
        """
        Check if trusted TRC is active and can be used for CertChain verification.

        :param TRC max_trc: newest available TRC for same ISD. (If none, self is newest TRC)
        :raises: SCIONVerificationError
        """
        now = int(time.time())
        if not (self.create_time <= now <= self.exp_time):
            raise SCIONVerificationError("Current time outside of validity period")
        if not max_trc or self.version == max_trc.version:
            return
        if self.version + 1 != max_trc.version:
            raise SCIONVerificationError("Invalid TRC version: %s. Expected %s or %s" % (
                self.version, max_trc.version, max_trc.version - 1))
        if now > max_trc.create_time + max_trc.grace_period:
            raise SCIONVerificationError("Grace period has passed")

    def verify(self, trusted_trc):
        """
        Verify TRC based on a trusted TRC.

        :param TRC trusted_trc: a verified TRC, used as a trust anchor.
        :raises: SCIONVerificationError
        """
        if self.isd == trusted_trc.isd:
            self.verify_update(trusted_trc)
        else:
            self.verify_xsig(trusted_trc)

    def verify_update(self, old_trc):
        """
        Verify TRC update.
        Unsuccessful verification raises an error.

        :param TRC old_trc: a verified TRC, used as a trust anchor.
        :raises: SCIONVerificationError
        """
        if old_trc.isd != self.isd:
            raise SCIONVerificationError("Invalid TRC ISD %s. Expected %s" % (
                self.isd, old_trc.isd))
        if old_trc.version + 1 != self.version:
            raise SCIONVerificationError("Invalid TRC version %s. Expected %s" % (
                self.isd, old_trc.isd))
        if self.create_time < old_trc.create_time + old_trc.grace_period:
            raise SCIONVerificationError("Invalid timestamp %s. Expected > %s " % (
                self.create_time, old_trc.create_time + old_trc.grace_period))
        if self.quarantine or old_trc.quarantine:
            raise SCIONVerificationError("Early announcement")
        self._verify_signatures(old_trc)

    def verify_xsig(self, neigh_trc):
        """
        Verify cross signatures.

        :param TRC neigh_trc: neighbour TRC, used as a trust anchor.
        :raises: SCIONVerificationError
        """
        pass

    def _verify_signatures(self, old_trc):
        """
        Perform signature verification for core signatures as defined
        in old TRC. Raises an error if verification is unsuccessful.

        :param: TRC old_trc: the previous TRC which has already been verified.
        :raises: SCIONVerificationError
        """
        # Only look at signatures which are from core ASes as defined in old TRC
        valid_signature_count = 0
        # Count number of verifiable signatures
        for signer in old_trc.core_ases.keys():
            public_key = self.core_ases[signer][ONLINE_KEY_STRING]
            try:
                verify(self._sig_input(), self.signatures[signer], public_key)
                valid_signature_count += 1
            except SCIONVerificationError:
                continue
        # Check if enough valid signatures
        if valid_signature_count < old_trc.quorum_trc:
            raise SCIONVerificationError("Not enough valid signatures %s. Expected %s" % (
                valid_signature_count, old_trc.quorum_trc))
